(function(exports, shim){

return exports.shim = shim;

// chrome
// var context = shim(document.body.appendChild(document.createElement("iframe")).contentWindow);
//
// node
// var context = shim(require('vm').createContext());

// or to just immediately shim the current global/window
// shim();

}.apply(this, function(global, exports, loadScript){
/**
 * Convert a context's Proxy implementation to use Direct Proxies. Then shim the DirectProxies shim
 * further so that it works more smoothly with current versions of V8.
 *
 * @option {Context|boolean}  [context]    In node this is a VM context. In a browser this is a window, like an iframe.
 *                                             If undefined the current global is used.
 * @option {String}           [path]       Path to the DirectProxies script. Defaults to 'DirectProxies.js' which works
 *                                             in the same  folder in Node or path in browser
 * @option {Function}         [callback]   Callback for when the shimming is done. If not provided the shim is loaded synchronously.
 * @return {Context|global}   The context or global
 */
  function shim(options){
    options = options || {};
    if (typeof options === 'function') {
      options = { callback: options };
    }
    if (typeof options === 'object' && 'Proxy' in options) {
      options = { context: options };
    }
    var path = options.path || 'DirectProxies.js';
    var context = options.context || global;

    if (typeof options.callback === 'function') {
      loadDirectProxies(path, function(e, script){
        options.callback(e, shimshim(script, context));
      });
    } else {
      return shimshim(loadDirectProxies(path), context);
    }
  }

  var directProxies;

  function loadDirectProxies(path, callback){
    var async = typeof callback === 'function';

    if (directProxies) {
      return async ? callback(null, directProxies) : directProxies;
    }

    if (async) {
      loadScript(path, function(e, script){
        if (script) directProxies = script;
        callback(e, script);
      });
    } else {
      var result = loadScript(path);
      if (typeof result === 'function') {
        directProxies = result;
      }
      return result;
    }
  }

  function shimshim(directProxies, context){
    if (!(directProxies && directProxies.runInContext && context)) return directProxies;
    try { directProxies.runInContext(context) }
    catch (e) { return e }
    // map proxies to their targets
    var proxies = new WeakMap;

    // shim the Proxy shim to intercept proxy creation so we can map proxies
    // to their target objects
    context.Proxy = (function(DirectProxy){

      // simple wrapper to snag the proxy and target references
      function Proxy(target, handler){
        return proxies.set(target, DirectProxy(target, handler));
      }

      // another simple wrapper
      function createFunction(handler, call, opt_construct){
        return proxies.set(call, DirectProxy.createFunction(handler, call, opt_construct));
      }

      // full copy of DirectProxies version because it never exposes the
      // target reference for us and has a scope reference to the unwrapped
      // Proxy shim so we can't intercept it
      function create(handler, proto) {
        var fakeTarget = Object.create(proto || null);
        var fakeHandler = Proxy(fakeTarget, {
          get: function(target, trapName, rcvr) {
            var trap = handler[trapName];
            if (trap === undefined) {
              return Reflect.VirtualHandler.prototype[trapName];
            }
            return trap;
          }
        });
        return Proxy(fakeTarget, fakeHandler);
      }

      Proxy.createFunction = createFunction;
      Proxy.create = create;

      return Proxy;

    })(context.Proxy);


    // Intercept GOPD calls to check if the target is a proxy and get the proxy's target.
    // If it is a proxy falsify the return descriptor so that it's always configurable. This
    // preempts the issues that arise in V8 without having to directly modify the shim itself.
    context.Object.getOwnPropertyDescriptor = (function(gopd){

      return function getOwnPropertyDescriptor(obj, prop){
        var desc = gopd.call(this, obj, prop);
        if (desc && proxies.has(obj)) {
          desc.configurable = true;
        }
        return desc;
      }

    })(context.Object.getOwnPropertyDescriptor);

    // Proxy is enumerable in V8 for some reason, and the shim doesn't bother to make
    // Reflect non-enumerable either.
    return Object.defineProperties(context, {
      Proxy:   { enumerable: false },
      Reflect: { enumerable: false }
    });
  }

  return [exports, shim];


}.apply(this, function(global, exports){


  function CompiledScript(code, name, run){
    this.code = code;
    this.name = name;
    this.runInContext = run;
  }

  // Filter out environments with require but not the specific (Node) module
  function hasModule(mod){
    if (typeof require !== 'function') return false;
    try { require(mod) }
    catch (e) { return false }
    return true;
  }

  var wrap = hasModule('vm')

  ? function wrap(name, code){
      var vm = require('vm');
      try { var script = vm.createScript(code, name) }
      catch (e) { return e }
      function runInContext(context){
        if (typeof context === 'undefined' || context === global) {
          script.runInThisContext();
          return global
        } else if (context + '' === '[object Context]') {
          // ensure the context is initiated
          vm.runInContext('this', context);
          script.runInContext(context);
          return context;
        }
      };
      return new CompiledScript(name, code, runInContext);
    }

  : function wrap(name, code){
      try {
        var wrapper = Function('with(this){return(function(){\n' + code + ' \n}.call(this))}');
      }
      catch (e) { return e }

      function runInContext(context){
        wrapper.call(context = context || global);
        return context;
      };
      return new CompiledScript(name, code, runInContext);
    }


  var loadScript = hasModule('fs')

  ? function loadScript(filepath, cb) {
      var fs = require('fs');
      var path = require('path');
      var exists = fs.existsSync || path.existsSync;

      var async = typeof cb === 'function';
      var resolved = filepath;

      if (!exists(resolved)) {
        resolved = path._makeLong(path.resolve(__dirname, resolved));
        if (!exists(resolved)) {
          var e = new Error("File " + filepath + " not found");
          if (async) return cb(e), false; else throw e;
        }
      }
      var name = path.basename(filepath);
      if (async) {
        fs.readFile(resolved,'utf8', function(e, code){
          if (e) cb(e);
          var result = wrap(name, code);
          typeof result === 'function' ? cb(null, result) : cb(result);
        })
      } else {
        return wrap(name, fs.readFileSync(resolved,'utf8'))
      }
    }

  : typeof XMLHttpRequest !== 'undefined'

  ? function loadScript(filepath, cb){
      var xhr = new XMLHttpRequest;
      var xhrError;
      var async = typeof cb === 'function';
      xhr.open('get', filepath, async);
      xhr.onerror = function(e){ xhrError = e }
      xhr.send();
      if (async){
        xhr.onload = function(){
          var result = xhrError ? xhrError : wrap(filepath, xhr.response);
          typeof result === 'function' ? cb(null, result) : cb(result);
        }
      } else {
        return xhrError ? xhrError : wrap(filepath, xhr.response);
      }
    }

  : false

  return [global, exports, loadScript];

}(
  typeof global !== 'undefined' ? global :
  typeof window !== 'undefined' ? window :
  this,
  typeof exports !== 'undefined' ? exports :
  typeof window !== 'undefined' ? window :
  {}
))))